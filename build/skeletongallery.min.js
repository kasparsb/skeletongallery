(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.webit || (g.webit = {})).skeletonGallery = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var b = function(p1x, p1y, p2x, p2y) {
    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
    var cx = 3.0 * p1x;
    var bx = 3.0 * (p2x - p1x) - cx;
    var ax = 1.0 - cx -bx;
         
    var cy = 3.0 * p1y;
    var by = 3.0 * (p2y - p1y) - cy;
    var ay = 1.0 - cy - by;

    var epsilon = 0.00001;

    function sampleCurveDerivativeX(t) {
        return (3.0 * ax * t + 2.0 * bx) * t + cx;
    }

    function sampleCurveX(t) {
        // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
        return ((ax * t + bx) * t + cx) * t;
    }

    function sampleCurveY(t) {
        return ((ay * t + by) * t + cy) * t;
    }

    // Given an x value, find a parametric value it came from.
    function solveCurveX(x)
    {
        var t0, t1, t2, x2, d2, i;

        // First try a few iterations of Newton's method -- normally very fast.
        for (t2 = x, i = 0; i < 8; i++) {
            x2 = sampleCurveX(t2) - x;
            if (Math.abs(x2) < epsilon) {
                return t2;
            }
            d2 = sampleCurveDerivativeX(t2);
            if (Math.abs(d2) < 1e-6) {
                break;
            }
            t2 = t2 - x2 / d2;
        }

        // Fall back to the bisection method for reliability.
        t0 = 0.0;
        t1 = 1.0;
        t2 = x;

        if (t2 < t0) {
            return t0;
        }
        if (t2 > t1) {
            return t1;
        }

        while (t0 < t1) {
            x2 = sampleCurveX(t2);
            if (Math.abs(x2 - x) < epsilon) {
                return t2;
            }
            if (x > x2) {
                t0 = t2;
            }
            else {
                t1 = t2;
            }
            t2 = (t1 - t0) * .5 + t0;
        }

        // Failure.
        return t2;
    }

    this.get = function(x) {
        return sampleCurveY(solveCurveX(x));
    }
}

module.exports = b;
},{}],2:[function(require,module,exports){
var _ = require('underscore');

/**
 * Vienots callback reģistrs visiem objektiem
 */
var registeredCallbacks = {};

var events = {
	on: function(eventName, callback) {		
		eventName = this.normalizeEventName(eventName);
		if (typeof registeredCallbacks[eventName] == 'undefined') {
			registeredCallbacks[eventName] = [];
		}
		registeredCallbacks[eventName].push(callback)
	},

	trigger: function(eventName) {
		var listeners = this.getListeners(eventName);
		for (var i in listeners) {
			listeners[i].apply(this, _.getArguments(1, arguments))
		}
	},

	/**
	 * Izpildām visus listeners un, kad tie visi izpildījušies
	 * un izpildījuši doneCallback, tad izpildās padoto doneCallback
	 */
	triggerWithCallback: function(eventName, doneCallback) {
		var listeners = this.getListeners(eventName);

		/**
		 * callback, kuru jāizsauc katram listener. Kad šis callback būs
		 * izsaukts listeners.length reizes, tad tiks izpildīts doneCallback
		 */
		var done = _.after(listeners.length, doneCallback);

		// Pirmo argumentu padodam done callback funkciju
		var args = _.getArguments(2, arguments);
		args.unshift(done);

		for (var i in listeners) {
			listeners[i].apply(this, args)
		}
	},

	/**
	 * Trigger only first attached event
	 */
	triggerFirst: function(eventName) {
		var listeners = this.getListeners(eventName);

		if (listeners.length > 0) {
			listeners[0].apply(this, _.getArguments(1, arguments))
		}
	},

	getListeners: function(eventName) {
		eventName = this.normalizeEventName(eventName);
		if (typeof registeredCallbacks[eventName] != 'undefined') {
			return registeredCallbacks[eventName];
		}
		return [];
	},

	/**
	 * Vai ir eventName piesaistīti klausītāji
	 */
	isListeners: function(eventName) {
		return this.getListeners(eventName).length > 0;
	},

	/**
	 * Katram eventam jāsākas ar klases vārdu
	 * Ja tas nav norādīts, tad kā klases vārdu ņemam this.name
	 */
	normalizeEventName: function(eventName) {
		var p = eventName.split('.');
		if (p.length == 1) {
			p.unshift(this.name);
		}
		return p.join('.');
		
	}
}

module.exports = events;
},{"underscore":15}],3:[function(require,module,exports){
var _ = require('underscore');
_.jQuery(jQuery);

module.exports = {
    'viewer': require('./viewer'),
    'thumbnails': require('./thumbnails'),
    'navigation': require('./navigation')
}
},{"./navigation":6,"./thumbnails":10,"./viewer":13,"underscore":15}],4:[function(require,module,exports){
var _ = require('underscore');
var media = require('./media');

var mediaImage = function(props) {
	/**
	 * Bildes dabīgie izmēri
	 * Kamēr bilde nav ielādējusie tikmēr width un height ir 0
	 */
	this.natural = {
		width: 0,
		height: 0
	}

	// Šajā gadījumā attēla adrese
	this.src = props.src;

	this.construct();
}

mediaImage.prototype = _.extend(media, {
	create: function() {
		var el = _.createEl('img');
		_.attr(el, 'src', this.src);
		return el;
	},

	checkIsLoaded: function() {
		// Nolasām attēla dimensijas
		this.readDimensions();

		if ( this.natural.width > 0 || this.natural.height > 0 ) {
			// Šajā mirklī uzstādām media kā ielādējušos
			this.setIsLoaded();

			return true;
		}
		else {
			_.on(this.el, 'load', _.bind(this.checkIsLoaded, this));

			return false;
		}
	},

	readDimensions: function() {
		this.natural = {
			width: this.el.width,
			height: this.el.height
		}
	}
});

module.exports = mediaImage;
},{"./media":5,"underscore":15}],5:[function(require,module,exports){
var _ = require('underscore');
var events = require('./events');

var media = _.extend({
	construct: function(props) {
		this.name = 'media';

		this.props = props;

		/**
		 * Pazīme, ka media lādējās
		 */
		this.loading = false;

		/**
		 * Iekšējais mainīgais. Pazīme, ka media ir ielādējusies
		 */
		this.loaded = false;

		/**
		 * Pazīme, ka media elements ir ievietots DOMā
		 */
		this.mounted = false;

		this.el = false;

		/**
		 * Media tiek ielādēts izsaucot metodi load
		 * Kamēr šī metode nav izsaukta tikmēr nekas saistīts ar DOM netiek darīts
		 */
	},

	/**
	 * Izveidojam Media DOM elementu un sākam media ielādēšanu
	 */
	load: function() {
		// Media elements (image utt)
		if (!this.el) {
			this.loading = true;
			this.trigger('beforeload', this);
			this.el = this.create();
			// Pārbaudām vai media elements ir ielādējies
			this.checkIsLoaded();
		}
	},

	/**
	 * !!Katrs media tips nodefinēš šo metodi
	 * 
	 * Veidojam media elementu.
	 */
	create: function() {
		console.warn('Define media create method');
	},

	/**
	 * !!Katrs media tips nodefinēs šo metodi
	 *
	 * Šeit pārbaudām vai attēls ir ielādējies un var nolasīt tā izmērus
	 * Ja attēls ir ielādējies un izmēri ir nolasīti palaižam load eventu
	 */
	checkIsLoaded: function() {
		console.warn('Define media checkIsLoaded method');
	},

	/**
	 * Metode, kuru izsauc, kad media elements ir ielādējies
	 */
	setIsLoaded: function() {
		this.loading = false;
		this.loaded = true;
		this.trigger('load', this);	
	},

	/**
	 * Atgriežam pazīmi, ka media ir ielādējusies
	 */
	isLoaded: function() {
		return this.loaded;
	},

	/**
	 * Liekam media elementu DOMā un uzstādām platumu, augstumu, lai
	 * media elements ieņem savu izmēru
	 * Dimensions: object with properties: width, height, maxWidth, maxHeight, minWith, minHeight
	 */
	mount: function(target, dimensions) {
		if (!this.mounted) {
			_.append(target, this.el);
			this.mounted = true;
		}
		this.setDimensions(dimensions);
	},

	/**
	 * Uzstādām media elementa platumu un augstumu
	 * Katrs media elements var pārrakstīt šo metodi pēc savām vajadzībām
	 * Pēc noklusējuma tiek uzstādīts css: {width, height, maxWidth, maxHeight, minWidth, minHeight}
	 */
	setDimensions: function(dimensions) {
		_.css(this.el, dimensions);

		this.readRealDimensions();
	},

	/**
	 * Nolasām esošos izmēru, kādi tie ir redzami uz ekrāna, pikseļos
	 */
	readRealDimensions: function() {
		this.width = _.width(this.el);
		this.height = _.height(this.el);
	}
}, events);

module.exports = media;

},{"./events":2,"underscore":15}],6:[function(require,module,exports){
var _ = require('underscore');

var navigation = function(props) {
	// Viewer instance
	this.viewer = props.viewer;

	this.next = props.next;
	this.prev = props.prev;

	this.setEvents();
}

navigation.prototype = {
	setEvents: function() {
		// Navigācijas pogas
		_.on(this.next, 'click', _.bind(function(ev){
			ev.preventDefault();
			this.viewer.next();
		}, this));

		_.on(this.prev, 'click', _.bind(function(ev){
			ev.preventDefault();
			this.viewer.prev();
		}, this));

		// Klaviatūras eventi
		_.on(window, 'keyup', _.bind(function(ev){
			switch ( ev.keyCode ) {
				case 39: this.viewer.next(); break;
				case 37: this.viewer.prev(); break;
			}
		}, this));
	}
}

module.exports = navigation;
},{"underscore":15}],7:[function(require,module,exports){
var _ = require('underscore');
var events = require('./events');
var mediaImage = require('./media-image');

/**
 * Izveidjot slide, tas pēc noklusējuma nesāk lādēt atbilstošo media
 * Lai sāktu ielādēt media, ir jāizsauc this.media.load un jāklausās load events
 */
var slide = function(props){
    this.name = 'slide';

    var defaultProps = {
        loadingCssClass: 'slide-loading',

        type: 'image',
        src: '',

        // Media default size
        width: '100%',
        height: 'auto',
        maxWidth: '',
        maxHeight: '',
        minWidth: '',
        minHeight: '',
        size: '',
        // Media alignment
        verticalAlign: 'top',
        horizontalAlign: 'center'
    };

    this.props = _.extend(defaultProps, props);

    this.loadingCssClass = this.props.loadingCssClass;

    // Izveidojam media instanci, bet pagaidām to vēl nelādējam
    this.media = new mediaImage({
        src: this.props.src
    });

    // Saglabājam referenci uz slide
    this.media.slide = this;

    this.setMediaEvents();

    /**
     * Pazīme vai slide ir ievietots DOMā
     */
    this.mounted = false;
    this.el = this.create();
}

slide.prototype = _.extend({
    create: function() {
        // Default css, kas tiek uzstādītis slide elementam
        var css = {
            maxWidth: '100%',
            maxHeight: '100%',
            height: '100%',
            width: '100%',
            overflow: 'hidden',
            position: 'relative'
        };

        var el = _.createEl('div');
        _.addClass(el, 'slide');
        _.css(el, css);

        return el;
    },

    setMediaEvents: function() {
        /**
         * Uzstādām slide, ka tas tiek ielādēts
         * Loading state tiek uzlikts false, tikai, kad media ir ielādējusies un iemontēta slaidā
         * Media loading un mounting ir viens process, tikai tas var būt sadalīts divās daļās
         * No sākuma var notikt loading un pēc tam mounting
         */
        this.media.on('beforeload', _.bind(function(){
            
            this.setLoadingState(true);

        }, this));

        // Media ir ielādējies, tagad varam montēt
        this.media.on('load', _.bind(function(){
            /**
             * mountCallback, kurš jāizpilda, kad media ielādēts
             * tas tiek uzstādits, kad slide tiek iemontēts
             * skatīt this.mount
             */
            if (this.media.isLoaded()) {
                if (typeof this.mountMediaLoadCallback == 'function') {
                    this.mountMediaLoadCallback();
                }
            }

        }, this));
    },

    /**
     * Ievietojam slide DOMā
     */
    mount: function(el) {
        if (!this.mounted) {
            _.append(el, this.el);
            this.mounted = true;

            //Šajā mirklī jāskatās vai media ir ielādēta, ja nav, tad tagad ir laiks to darīt
            if (this.media.isLoaded()) {
                // Ja media ir ielādējusies, tad varam montēt media slaidā
                this.mountMedia();
            }
            else {
                /**
                 * Izveidojam callback, kuru izpildīs, kad media būs ielādējusies,
                 * ja slide būs atmonēts uz mirkli, kad media ir ielādējusies, tad
                 * šis callback jau būs nodzēsts un tas neizpildīsies
                 * Taisot unmount šis callback nodzēšanas
                 * Šis callback tiek pārbaudīts un izpildīts this.media.on.load
                 * skatīt this.unmount
                 */
                this.mountMediaLoadCallback = _.bind(this.mountMedia, this);
                this.media.load();
            }
            
        }
    },

    unmount: function() {
        // Nodzēšam mount callback, jo nav jēgas to izpildīt kamēr slide nav iemontēts
        if (typeof this.mountMediaLoadCallback != 'undefined') {
            delete this.mountMediaLoadCallback;
        }

        if (this.mounted) {
            _.remove(this.el);
            this.mounted = false;
        }
    },

    /**
     * Ievietojam media DOMā tikai, kad slide ir ievietots DOMā. 
     * Tas vajadzīgs, lai tiktu noteikti pareizi media izmēri
     * Gadījumā, ja media jau iepriekš bija ielādēts, bet uz mirkli
     * kad media ielādējies, slide jau bija izvākts no DOMa, tad
     * netiek izpildīts mountMedia un slide joprojām ir loading stāvoklī
     * Nākošreiz, kad slide tiks ievietots DOMā mountMedia tiks izpildīts un
     * slide iegūs loaded stāvokli
     */
    mountMedia: function() {
        if (this.mounted) {
            
            var actualMounting = _.bind(function(){
                // Montējot media padodam izmērus
                this.media.mount(
                    this.el,
                    this.getMediaDimensionsProperties()
                );

                this.beforeAlignMedia(alignDone);
            }, this)

            var alignDone = _.bind(function(){
                // Pēc mount
                this.afterMount(mountingDone);
            }, this);

            var mountingDone = _.bind(function(){
                
                this.setLoadingState(false);

                // Paziņojam, ka slide ar media ir iemontēts
                this.trigger('mount', this);

            }, this);

            // Pirms media iemontēšanas
            this.beforeMount(actualMounting);
        }
    },

    /**
     * Callback ir jāizsauc, kad visas darbības ar ievietojamo media ir izdarītas
     */
    beforeMount: function(doneCallback) {
        // Media elements vienmēr ir absolūti pozicionēts, lai būtu vienkāršāk veidot align
        var defaultMediaElCss = {
            position: 'absolute',
            display: 'block'
        }
        
        if (this.isListeners('beforemount')) {
            // Padodam callback funkcijai default MediaEl css
            this.triggerWithCallback('beforemount', doneCallback, this, _.clone(defaultMediaElCss));
        }
        else {
            _.css(this.media.el, defaultMediaElCss);
            doneCallback();
        }
    },

    /**
     * Metode, kas izpildās pēc tam, kad media elements ir ievietots slaidā
     * Šai metodei tiek padots callback, kurš ir jāizsauc, kad visas darbības
     * ar media ir pabeigts un media ir pilnībā ielādēts
     */
    afterMount: function(doneCallback) {
        if (this.isListeners('aftermount')) {
            this.triggerWithCallback('aftermount', doneCallback, this);
        }
        else {
            doneCallback()
        }
    },

    beforeAlignMedia: function(doneCallback) {
        if (this.isListeners('beforealignmedia')) {
            this.triggerWithCallback('beforealignmedia', doneCallback, this);
        }
        else {
            this.alignMedia(doneCallback);
        }
    },

    /**
     * Pozicionējam media elementu atkarībā no padotās konfigurācijas
     */
    alignMedia: function(doneCallback) {
        var css = {}

        css = this.align.y[this.props.verticalAlign](css, this.media);
        css = this.align.x[this.props.horizontalAlign](css, this.media);

        _.css(this.media.el, css);

        if (typeof doneCallback == 'function') {
            doneCallback();
        }
    },

    /**
     * Force slide and media element resize according to new viewer size
     */
    resize: function() {
        // Uzstādām izmērus
        this.media.setDimensions(this.getMediaDimensionsProperties());
        // Align media elementu
        this.alignMedia();
    },

    css: function(cssRules) {
        _.css(this.el, cssRules);
    },

    /**
     * Uzstādām slide loading indikāciju
     */
    setLoadingState: function(isLoading) {
        _[isLoading ? 'addClass' : 'removeClass'](this.el, this.loadingCssClass)
    },

    /**
     * Savācam media dimensions objektu. 
     * Tas tiek padots media, kad to mount vai resize
     */
    getMediaDimensionsProperties: function() {
        var p = {
            width: this.props.width,
            height: this.props.height,
            maxWidth: this.props.maxWidth,
            maxHeight: this.props.maxHeight,
            minWidth: this.props.minWidth,
            minHeight: this.props.minHeight
        }; 

        /**
         * !! Sizing method
         * fit - media iekļaujas atvēlētajā rāmī
         *   width, height - empty
         *   maxWidth, maxHeight: 100%
         * cover - media pārklāj atvēlēto rāmi
         */
        switch (this.props.size) {
            case 'cover':
                var s = this.calculateDimensionsCover();
            case 'fit':
                var s = this.calculateDimensionsFit();
            default: 
                if (s) {
                    p.width = s.width;
                    p.height = s.height;
                    p.maxWidth = '';
                    p.maxHeight = '';
                    p.minWidth = '';
                    p.minHeight = '';

                    //console.log(p.width, p.height, this.media.natural, this.props.src);
                }
        }
        
        return p;
    },

    /**
     * Aprēķinām media elementa izmērus priekš izmēra Cover
     */
    calculateDimensionsCover: function() {
        var cw = _.width(this.el);
        var ch = _.height(this.el);

        var mw = this.media.natural.width;
        var mh = this.media.natural.height;
        // Malu attiecība
        var mr = mw/mh;

        // Vajag cover izmērus      
        var w = cw;
        var h = w/mr;

        if (h < ch) {
            h = ch;
            w = h*mr;
        }

        return {
            width: w,
            height: h
        }
    },

    /**
     * Aprēķinām media elementa izmērus priekš fit
     */
    calculateDimensionsFit: function() {
        var cw = _.width(this.el);
        var ch = _.height(this.el);

        var mw = this.media.natural.width;
        var mh = this.media.natural.height;
        // Malu attiecība
        var mr = mw/mh;

        // Resize to width
        var w = cw;
        var h = w/mr;

        if (h > ch) {
            h = ch;
            w = h*mr;
        }

        return {
            width: w,
            height: h
        }
    },

    /**
     * Align metodes
     */
    align: {
        x: {
            left: function(css, media) {
                css.left = 0;
                return css;
            },
            right: function(css, media) {
                css.right = 0;
                return css;
            },
            center: function(css, media) {
                css.left = '50%';
                css.marginLeft = -(media.width/2)
                return css;
            }
        },
        y: {
            top: function(css, media) {
                css.top = 0;
                return css;
            },
            bottom: function(css, media) {
                css.bottom = 0;
                return css;
            },
            center: function(css, media) {
                css.top = '50%';
                css.marginTop = -(media.height/2)
                return css;
            }
        }
    },
}, events);

module.exports = slide;
},{"./events":2,"./media-image":4,"underscore":15}],8:[function(require,module,exports){
var _ = require('underscore');
var events = require('./events');
var slide = require('./slide');
var mediaImage = require('./media-image');

/**
 * Viewer vajadzīgs, lai
 * 1) Nolasītu no viewer props slideDefault parametrus
 * 2) Klausītos viewer change eventu
 */
var slides = function(items, viewer) {
    this.preloadThreshold = 2;
    this.active = false;
    this.rotate = true;
    this.viewer = viewer;
    
    this.setEvents();

    this.setItems(items);
}

slides.prototype = _.extend({

    /**
     * Sākam veidot slaidus
     */
    create: function(items) {
        return items.map(function(item, index){
            return this.createItem(item, index);
        }, this);
    },

    /**
     * Veidojam slide objektu
     * @param object Slide definition
     * @param number Slide index
     */
    createItem: function(def, index) {
        var o = new slide(
            _.extend(
                _.clone(this.viewer.slideDefaultProps), 
                // ja nav objekts, tad taisām kā objektu
                typeof def == 'object' ? def : { src: def }
            )
        );

        // Katram slide pieglabājam tā index
        o.index = index;
        // Add css class
        _.addClass(o.el, 'slide-'+o.index);

        return o;
    },

    setItems: function(items) {
        this.items = this.create(items);
        this.length = this.items.length;
    },

    setEvents: function() {
        var handlePreload = _.bind(this.handlePreload, this);

        // Kad media ir ielādējusies, tad skatamies vai nevajag veikt nākošo preload
        this.on('media.load', handlePreload);
        // To pašu darām, kad viewerī nomainās slide
        this.viewer.on('change', handlePreload);
    },

    /**
     * Kad media elements ielādējies, skatamies vai vajag preload nākošos
     * Skatamies, lai būt ielādēti vismaz this.active.index + this.preloadThreshold slaidi
     */
    handlePreload: function() {
        var preload = function(items) {
            var loadedAny = false;

            _.each(items, function(slide){
                if (!slide.media.loaded && !slide.media.loading) {
                    slide.media.load();
                    loadedAny = true;
                    return false;
                }
            });

            return loadedAny;
        }

        var start = this.active ? this.active.index : 0;

        // Preload slaidus pa labi no this.active
        var loadedAny = preload(this.get(start, this.preloadThreshold));
        // Ja ir rotate, tad preload slaidus pa kreisi no active
        if (!loadedAny && this.rotate) {
            preload(this.get(start, -this.preloadThreshold))
        }
    },

    /**
     * Is this slide active
     */
    isActive: function(slide) {
        return slide.index == this.active.index;
    },

    setActive: function(slide) {
        this.active = slide;
    },

    /**
     * Get slide by index. If provided count, than return array of slides
     * @param number Slide index
     * @param number How many slides from index to return
     */
    get: function(index, offset) {
        index = _.normalizeIndex(index, this.length);

        if (typeof offset != 'undefined') {
            return _.ranger(index, index+offset, function(i){
                return this.items[_.normalizeIndex(i, this.length)];
            }, this);
        }
        else {
            return this.items[index];
        }
    },

    getByOffset: function(offset) {
        return this.get(_.checkBoundry(this.active ? this.active.index+offset : 0, this.length, this.rotate));
    },

    getNext: function() {
        return this.getByOffset(1);
    },

    getPrev: function() {
        return this.getByOffset(-1);
    },

    replaceItems: function(newItems) {
        this.setItems(newItems);
    }
}, events);

module.exports = slides;
},{"./events":2,"./media-image":4,"./slide":7,"underscore":15}],9:[function(require,module,exports){
var Bezier = require('./bezier2.js');

var Stepper = function() {
    /**
     * Frames per second
     */
    this.fps = 60;
    this.interval = 1000 / this.fps;
    this.precision = 100000;
    this.progress = 0;
    this.current = 0;
}

Stepper.prototype = {
    run: function(duration, bezierCurve, stepCb, doneCb) {
        this.stepCallback = stepCb;
        this.doneCallback = doneCb

        //this.easing = new KeySpline(bezierCurve[0], bezierCurve[1], bezierCurve[2], bezierCurve[3]);
        this.easing = new Bezier(bezierCurve[0], bezierCurve[1], bezierCurve[2], bezierCurve[3]);
        

        this.duration = duration;
        this.current = 0;

        this.start();
        this.step();
    },

    /**
     * Run from given progress
     */
    runFrom: function(progress, duration, bezierCurve, stepCb, doneCb) {
        this.stepCallback = stepCb;
        this.doneCallback = doneCb

        //this.easing = new KeySpline(bezierCurve[0], bezierCurve[1], bezierCurve[2], bezierCurve[3]);
        this.easing = new Bezier(bezierCurve[0], bezierCurve[1], bezierCurve[2], bezierCurve[3]);
        
        this.duration = duration;

        this.startTime = +new Date();
        this.startTime -= (duration * progress);
        this.progress = progress;

        this.step();
    },

    /**
     * Piefiksējam sākuma laiku
     */
    start: function() {
        this.startTime = +new Date();
        this.progress = 0;        
    },

    done: function() {
        this.doneCallback();
    },

    step: function() {
        var mthis = this;

        mthis.trackProgress();

        if (this.current < this.startTime + this.duration) {

            this.stepCallback(this.progress);

            var cb = function(){
                mthis.step()
            }

            requestAnimationFrame(cb);
            //setTimeout(cb, this.interval);
        }
        else {
            this.stepCallback(1);

            this.done();
        }
    },

    trackProgress: function() {
        // Current time
        this.current = +new Date();

        var delta = this.current - this.startTime;

        // Animation progress in precents
        this.progress = this.easing.get(delta / this.duration);

        this.progress = Math.round(this.progress*this.precision)/this.precision;
    }
}

module.exports = Stepper;
},{"./bezier2.js":1}],10:[function(require,module,exports){
var _ = require('underscore');
var events = require('./events');

/**
 * Thumbnails types:
 * - ar bildēm
 * - bumbiņas. Principā vienalga kāds grafiskais elements
 * - counter. i from length - šis pat nav vajadzīgs, jo var klausīties viewer eventus un attiecīgi reaģēt
 * 
 * Horizontāls
 * Vertikāls
 */


var thumbnails = function(props) {
	this.name = 'thumbnails';
	this.props = props;

	this.el = this.create();
	this.items = this.createItems(props.items);

	this.setEvents();
}

thumbnails.prototype = _.extend({
	setEvents: function() {

		// If provided vewier, watch change event
		if (this.props.viewer) {
			this.props.viewer.on('change', _.bind(this.handleChange, this));
		}

		// If next, prev controls, handle click
		if (this.props.next) {
			_.on(this.props.next, 'click', _.bind(function(ev){
				ev.preventDefault();

				this.next();
			}, this))
		}

		if (this.props.prev) {
			_.on(this.props.prev, 'click', _.bind(function(ev){
				ev.preventDefault();

				this.prev();
			}, this))
		}
	},

	handleChange: function() {

	},

	create: function() {
		var el = _.createEl('div');
	},

	createItems: function(items) {
		items.map(function(item){
			var el = this.props.formatter.call(this, item);

			_.append(this.el, el)

			
		}, this)
	}
}, events);

module.exports = thumbnails;
},{"./events":2,"underscore":15}],11:[function(require,module,exports){
var _ = require('underscore');
var swipe = require('swipe');

function viewerSwipe(viewer) {
    this.viewer = viewer;

    /**
     * Viewer dimensijas swipošanas brīdī
     */
    this.dimensions = {}

    // Swipe progress 0 - started, 1 - finished
    this.progress = 0;

    /**
     * Swipe direction. No swipe nosakām, kādā virzienā
     * ir jāpārslēdz slides. Šis var būt atkarīgs no viewer konfigurācijas
     * Horizontālā swipe vertikālā
     * Direction vienmēr būs next vai prev
     */
    this.direction = 'horizontal';

    // Slide, uz kuru mēģina pārslēgties
    this.newSlides = {
        prev: null,
        next: null
    }


    this.initSwipe();
    this.setEvents();
}

viewerSwipe.prototype = {
    setEvents: function() {
        this.swipe.on('start', _.bind(this.onStart, this));
        this.swipe.on('end', _.bind(this.onEnd, this));
        this.swipe.on('move', _.bind(this.onMove, this))
    },

    initSwipe: function() {
        var c = {};

        if (this.direction) {
            c.direction = this.direction;
        }

        this.swipe = new swipe(this.viewer.el, c);
    },

    onStart: function(ev) {
        this.dimensions = this.viewer.getDimensions();

        this.newSlides = {
            prev: null,
            next: null
        }
        this.swipeStarted = true;
        this.swipeProgress = 0;
        this.direction = null;
        this.transitionStarted = false;
    },

    onEnd: function(ev) {
        if (!this.swipeStarted) {
            return;
        }

        this.viewer.transition.runFrom(this.swipeProgress)
    },

    onMove: function(ev) {
        if (!this.swipeStarted) {
            return;
        }

        this.startTransition();

        this.trackDirection(ev);
        this.trackNewSlides();
        this.trackProgress(ev);
    },

    /**
     * Pārbaudām vai vajag sākt transition stepping. Ja ir iesākts stepping,
     * tad neko nedarām
     */
    startTransition: function(direction) {
        if (this.transitionStarted) {
            return;
        }

        this.transitionStarted = true;
            
        this.viewer.transition.start(this.viewer.slides.active);
    },

    trackProgress: function(ev) {
        this.swipeProgress = ev.width / this.dimensions.width;

        this.viewer.transition.step(this.swipeProgress);
    },

    trackDirection: function(ev) {
        this.direction = this.getDirection(ev);

        this.viewer.transition.setDirection(this.direction);
    },

    trackNewSlides: function() {
        return;
        if (!this.newSlides[this.direction]) {
            this.newSlides[this.direction] = this.direction == 'next'
                ? 
                this.viewer.slides.getNext()
                :
                this.viewer.slides.getPrev();


            this.viewer.transition.setNewSlide(
                this.newSlides[this.direction],
                this.direction
            );
        }
    },

    getDirection: function(ev) {
        return ev.offset.x <= 0 ? 'next' : 'prev';
    }
}

module.exports = viewerSwipe;
},{"swipe":14,"underscore":15}],12:[function(require,module,exports){
var _ = require('underscore');
var events = require('./events');
var stepper = require('./stepper');

function viewerTransition(viewer) {
    this.name = 'viewerTransitions';

    this.viewer = viewer;
    this.transition = viewer.props.transition;

    this.stepper = new stepper();
}

viewerTransition.prototype = _.extend({

    setDirection: function(direction) {
        this.direction = direction;

        return this;
    },

    setNewSlide: function(slide, direction) {
        // Ja ienāk pirmais slide, tad nav direction
        if (direction) {
            this.newSlides[direction] = slide;
            this.transition.newSlide(slide, direction, this.viewer);
        }

        return this;
    },

    start: function(currentSlide) {
        this.newSlides = {
            next: null,
            prev: null
        }
        this.direction = null;

        this.currentSlide = currentSlide;

        // Šajā mirklī notiek current slide pozicionēšana
        this.transition.before(this.currentSlide, this.viewer);

        return this;
    },

    run: function() {
        // Ja nav direction, tad neturpinam
        if (!this.direction) {
            return;
        }

        // Ja nav ne next ne prev slide, tad neturpinām
        if (this.newSlides.next == null && this.newSlides.prev == null) {
            return;
        }

        this.trigger('start');
        this.stepper.run(
            this.transition.duration,
            this.transition.easing,

            _.bind(this.step, this),

            _.bind(this.end, this)
        );
    },

    step: function(progress) {
        this.transition.step(this.currentSlide, this.newSlides, this.direction, progress, this.viewer);
    },

    end: function() {
        this.trigger('end');
        //this.transition.after(this.currentSlide, this.newSlide, this.direction, this.viewer);
    },


    

    runFrom: function(progress) {
        this.stepper.runFrom(
            progress,
            this.transition.duration,
            this.transition.easing,

            _.bind(this.step, this),

            _.bind(this.end, this)
        );
    }
}, events);

module.exports = viewerTransition;
},{"./events":2,"./stepper":9,"underscore":15}],13:[function(require,module,exports){
var _ = require('underscore');
var events = require('./events');
var slides = require('./slides');
var Transition = require('./viewer-transition');
var Swipe = require('./viewer-swipe');

var viewer = function(props, items) {
	this.name = 'viewer';

	this.props = _.extend({
		// Handle window resize and resize viewer
		handleWindowResize: false,
		// Where to switch to first slide when reached end
		rotate: false,
		// Immediatly show first slide
		autoStart: false,
		/**
		 * Pazīme, ka pirms slaidu pārslēgšanas tiek pārbaudīts 
		 * vai slidesTransitionInProgress == true
		 * ja true, tad slaidi netiek pārslēgti, tiek gaidīts kamēr beigsies transition
		 * pretējā gadījumā tiek pārslēgti slaidi un tiek palaists nākošo slides transition
		 */
		checkSlidesTransitionInProgress: true
	}, props);

	this.items = items;

	// Slide Default properties
	this.slideDefaultProps = this.props.slideDefault || {};

	// Elements, kurā jādarbojas viewerim
	this.container = props.container;

	// Viewer elements
	this.el = this.create();

	/**
	 * Pazīme, ka notiek slide transition
	 * Kamēr notiek slide transition tikmēr netiek pārslēgti slide
	 */
	this.slidesTransitionInProgress = false;

	this.preloadThreshold = 4;

	// Iemontēto slide rinda
	this.mountQueue = [];

	this.transition = new Transition(this);
	this.swipe = new Swipe(this);

	this.init();
}

viewer.prototype = _.extend({
	
	init: function() {
		// Slides
		this.slides = new slides(this.items, this);
		this.slides.rotate = this.props.rotate;
		this.slides.preloadThreshold = this.preloadThreshold;

		this.setEvents();

		// Check if we need to automaticaly load first slide
		if (this.props.autoStart) {
			this.first();
		}
	},

	setEvents: function() {
		// Check if we need to handle window resize and resize viewer
		if (this.props.handleWindowResize) {
			_.on(window, 'resize', _.debounce(this.handleWindowResize, 100, this));
		}

		/**
		 * Uzliekam transition eventus
		 * Transition ir animācija, kur var notikt noteiktu laiku, tāpēc
		 * vajag iespēju piefiksēt, kad notiek šī animācija
		 */
		this.transition.on('start', _.bind(function(){
			this.slidesTransitionInProgress = true;
		}, this));

		this.transition.on('end', _.bind(function(){
			this.slidesTransitionInProgress = false;

			this.trigger('change');
		}, this))
	},

	handleWindowResize: function() {
		this.resize();
	},

	/**
	 * Create viewer DOM element
	 * Do not make any DOM manipulations on actual container
	 */
	create: function() {
		var el = _.createEl('div');
		var css = {
			display: 'block',
			position: 'relative',
			overflow: 'hidden',
			height: _.height(this.container)
		}
		_.css(el, css);
		_.append(this.container, el);
		return el;;
	},

	/**
	 * Montējam slide, lai tas būt ievietots DOMā
	 * Montējot slide notiek media ielāde, ja tā vēl nav ielādēta
	 */
	mountSlide: function(slide) {
		slide.mount(this.el);
	},

	unmountSlide: function(slide) {
		this.dequeueSlide(slide);
		slide.unmount();
	},

	queueSlide: function(slide) {
		this.mountQueue.push(slide);
		this.setSlidesMountIndexes();
	},

	dequeueSlide: function(slide) {
		var i = -1;
		for (var g in this.mountQueue) {
			if (this.mountQueue[g].index == slide.index) {
				i = g;
				break;
			}
		}
		if (i >= 0) {
			this.mountQueue.splice(i, 1);
		}
		delete slide.mountIndex;
		this.setSlidesMountIndexes();
	},

	setSlidesMountIndexes: function() {
		for (var i = 0; i < this.mountQueue.length; i++) {
			this.mountQueue[i].mountIndex = i;
		}
	},


	/**
	 * Noklusētais slide mount events. Ja un slide mount nav nodefinēts events, tad šis 
	 * būs noklusētais, kurš tiks izpildīts
	 */
	handleSlideMountEvent_mount: function(slide) {
		if (this.slides.isActive(slide)) {
			// Izsaukt attiecīgo event, tikai, kad ienāk active slide
			_.css(this.el, {
				height: slide.media.height
			})
		}
	},

	startTransitionStepping: function(direction) {
		/**
		 * @todo Šo mainīgo pārsaukt savādāk
		 */
		this.tempState = {
			newSlide: this.slides[direction == 'next' ? 'getNext' : 'getPrev'](),
		    oldSlide: this.slides.active,
		    direction: direction
		}

		this.queueSlide(this.tempState.newSlide);
		
		// Uzstādām aktīvo slide
		this.slides.setActive(this.tempState.newSlide);

		// Uzsākam transition
		this.props.transition.before(this.tempState.oldSlide, this.tempState.newSlide, 'next', this);
	},

	setTransitionProgress: function(progress) {
		
		this.props.transition.step(this.tempState.oldSlide, this.tempState.newSlide, 'next', progress, this);
		
	},

	/**
	 * Atgriež esošos viewer izmērus
	 * @todo Izmērus ir jākešo
	 */
	getDimensions: function() {
		return {
			width: _.width(this.el),
			height: _.height(this.el)
		}
	},

	resize: function() {
		_.css(this.el, {
			height: _.height(this.container)
		});

		if (this.slides.active) {
			this.slides.active.resize();	
		}
	},

	/**
	 * Nomainām slide, sagatavojam transition, bet nepalaižam to
	 */
	changeSlide: function(newSlide) {
		if (this.props.checkSlidesTransitionInProgress && this.slidesTransitionInProgress) {
			return false;
		}

		// Ja ienāk aktīvais slaids, tad neko nedarām
		if (this.slides.isActive(newSlide)) {
			return false;;
		}

		this.slides.setActive(newSlide);

		return true;
	},

	/**
	 * Show slide by index
	 */
	show: function(newSlide, direction) {
		// Vecais slide
		var currentSlide = this.slides.active;

		// Turpinām, tikai, ja slide ir nomainīts
		if (this.changeSlide(newSlide)) {

			// Ieliekam slaidu rindā. Ja Viewerī tiek likti vairāki slaidi, tad vajag kontrolēt to secību
        	this.queueSlide(newSlide);

			this.transition
				// Iestartējam transition
				.start(currentSlide ? currentSlide : newSlide)
				.setDirection(direction)
				.setNewSlide(newSlide, direction)
				// Palaižam transition
				.run();
		}
	},

	first: function() {
		this.show(this.slides.get(0));
	},

	/**
	 * Navigate to next slide
	 */
	next: function() {
		this.show(this.slides.getNext(), 'next');
	},

	/**
	 * Navigate to prev slide
	 */
	prev: function() {
		this.show(this.slides.getPrev(), 'prev');
	},

	/**
	 * Change current loade slides for new ones
	 * @param array New slides
	 * @param number Slide index to load. If not passed, first slide will be loaded
	 */
	replaceItems: function(newItems, index) {
		if (typeof index == 'undefined') {
			index = 0;
		}

		// Unmount currently active slide
		this.unmountSlide(this.slides.active);

		// Replace slides
		this.slides.replaceItems(newItems);

		// Set active slide and mount
		this.slides.setActive(this.slides.get(index));
		this.mountSlide(this.slides.active);
	}
}, events);

module.exports = viewer;
},{"./events":2,"./slides":8,"./viewer-swipe":11,"./viewer-transition":12,"underscore":15}],14:[function(require,module,exports){
(function(root, factory){

    if (typeof exports === 'object') {
        module.exports = factory();
    }
    else {
        if (typeof root.webit == 'undefined') {
            root.webit = {}
        }
        root.webit.swipe = factory();
    }

})(this, function(){
    var Swipe = function(el, config) {
        // Touch/mouse events will be attaches to body
        this.swipeEl = document.getElementsByTagName('body')[0];

        this.el = el;

        this.events = this.prepareEvents(
            ["swipe", "move", "start", "end", "touchend", "touchmove"]
        );

        // Apply configuration
        this.config(config);

        // Allowed touches count. When swiping we need only one touch
        this.touchesCount = 1;
        // Slope factor to distinguise vertical swipe from horizontal
        this.slopeFactor = 1;
        // First touch when touch start occures
        this.startTouch = false;
        // Current touch, when swipe is in process
        this.currentTouch = undefined;

        // Swipe width
        this.width;
        // Swipe height
        this.height;
        // Swipe duration
        this.duration;
        // In case of directional swipe, this will be initial swipe direction (horizontal or vertical)
        this.moveDirection = null;

        /**
         * Is touch events supported
         * This will be determined when first touchstart event fires
         */
        this.isTouchEvents = false;

        /**
         * Is touch started on this.el
         */
        this.isTouchedValidElement = false;

        this.handleEvents('add');

        return this;
    }

    Swipe.prototype = {
        prepareEvents: function(eventNames) {
            var r = {};
            for ( var i in eventNames ) {
                r[eventNames[i]] = [];
            }
            return r;
        },

        handleEvents: function(method) {
            var mthis = this;

            var start = function(ev) {
                if (mthis.isTheElement(mthis.eventTarget(ev))) {
                    this.isTouchedValidElement = true;

                    mthis._start(ev);
                }
                else {
                    this.isTouchedValidElement = false;
                }
            }
            
            var end = function(ev) {
                if (this.isTouchedValidElement) {
                    mthis._end(ev);

                    this.isTouchedValidElement = false;
                }
            }

            var move = function(ev) {
                if (this.isTouchedValidElement) {
                    mthis._move(ev);
                }
            }

            
            // Ja izpildīsies touchstart, tad mouse eventus vairāk neklausāmies
            var touchStart = function(ev) {
                mthis.isTouchEvents = true;
                start(ev);
            }

            var touchEnd = function(ev) {
                end(ev);
            }

            var touchMove = function(ev) {
                move(ev)
            }


            // Ja ir toucheventi, tad mouse eventus neizpildām
            var mouseStart = function(ev) {
                if (!mthis.isTouchEvents) {
                    start(ev)   
                }
            }

            var mouseEnd = function(ev) {
                if (!mthis.isTouchEvents) {
                    end(ev) 
                }
            }

            var mouseMove = function(ev) {
                if (!mthis.isTouchEvents) {
                    move(ev)
                }
            }

            var eventMethod = method == 'add' ? 'addEvent' : 'removeEvent';

            this[eventMethod](this.swipeEl, 'touchstart', touchStart);
            this[eventMethod](this.swipeEl, 'touchmove', touchMove);
            this[eventMethod](this.swipeEl, 'touchend', touchEnd);
        
            this[eventMethod](this.swipeEl, 'mousedown', mouseStart);
            this[eventMethod](this.swipeEl, 'mousemove', mouseMove);
            this[eventMethod](this.swipeEl, 'mouseup', mouseEnd);
        },

        /**
         * Touch start. When touch starts or when mouse down
         */
        _start: function(ev) {
            this.startTouch = this.getTouch(ev);
            this.validMove = false;
            this.moveDirection = null;

            this.fire("start", [this.startTouch]);
        },

        /**
         * Touch ends
         */
        _end: function(ev) {
            this.currentTouch = this.getTouch(ev);

            this.trackMovment();

            this.startTouch = false;

            if (this.validMove) {
                this.fire("end", [this.formatSwipe()]);
             }

            // Vienmēr izpildām touchend eventu
            this.fire("touchend", [this.formatSwipe()]);
        },

        /**
         * Touch is moving. Moving when mouse down
         */
        _move: function(ev) {
            // Check for startTouch when fired mousemove event
            if (this.startTouch) {

                this.currentTouch = this.getTouch(ev);

                this.trackMovment();

                // Always retranslate touchmove if there was move
                this.fireTouchMove();

                if (this.isValidMove()) {
                    this.preventEvent(ev);
                    this.validMove = true;
                }
                else {
                    this.validMove = false;   
                }
                
                if (this.validMove) {
                    this.fire("move", [this.formatSwipe()])
                }
            }
        },

        formatSwipe: function() {
            return {
                direction: this.direction,
                offset: this.offset,
                duration: this.duration,
                width: this.width,
                height: this.height,
                x: this.currentTouch.x,
                y: this.currentTouch.y,

                speed: this.width / this.duration
            }
        },

        /** 
         * There we can filter if current move is valid
         * For, example, if we track only horizontal move, then ignore
         * vertical move.
         * There also can be checked, if user is scrolling page
         */
        isValidMove: function() {
            var valid = true;

            /**
             * Ja ir directional swipe, tad ja ir nodetektēts direction
             * atbilstošs swipe, vairāk to nepārtraucam. Jo swipe laikā
             * var mainīties direction, no left kļūt par top
             */
            
            // Swipe direction
            if (this._config.direction) {
                
                // Uzstādām pirmo dektēto swipe virzienu
                if (!this.moveDirection) {
                    if (this.isHorizontal()) {
                        this.moveDirection = 'horizontal';
                    }
                    else if (this.isVertical()) {
                        this.moveDirection = 'vertical';
                    }
                }

                if (this.moveDirection != this._config.direction) {
                    return false;
                }
            }

            var minMaping = {minWidth: 'width', minHeight: 'height', minDuration: 'duration'};
            var maxMaping = {maxWidth: 'width', maxHeight: 'height', maxDuration: 'duration'};

            for (var p in minMaping) {
                if (this._config[p]) {
                    if (this[minMaping[p]] < this._config[p]) {
                        return false;
                    }    
                }
                
            }

            for (var p in maxMaping) {
                if (this._config[p]) {
                    if (this[maxMaping[p]] > this._config[p]) {
                        return false;
                    }
                }
            }

            return true;
        },

        isHorizontal: function() {
            return (this.direction == "left" || this.direction == "right");
        },

        isVertical: function() {
            return (this.direction == "up" || this.direction == "down");
        },

        /**
         * Track swipe progress. Calculates swipe width, height and duration
         */
        trackMovment: function() {
            this.offset = {
                x: this.currentTouch.x - this.startTouch.x,
                y: this.currentTouch.y - this.startTouch.y
            };
            this.width = Math.abs(this.offset.x);
            this.height = Math.abs(this.offset.y);
            this.duration = this.currentTouch.t - this.startTouch.t;
            this.direction = this.getDirection()
        },

        /**
         * Get swipe direction
         */
        getDirection: function() {
            /**
             * Horizontal swipe elevation
             * When swiping left right there van be slight elveation, but this
             * does not mean user is swiping up or down
             */
            var e = this.offset.y / this.offset.x;

            if (e > this.slopeFactor) {
                return "up";
            }
            else if (e < -this.slopeFactor) {
                return "down";
            }
            else if (this.currentTouch.x >= this.startTouch.x) {
                return "right";
            }
            else if (this.currentTouch.x < this.startTouch.x) {
                return "left";
            }
        },

        /**
         * Get touch object from event
         * We nned only x, y coordinates and time of touch
         */
        getTouch: function(ev) {
            var t = false;
            var changedTouches = ev.changedTouches;
            
            if (changedTouches) {
                // Allow only defined number of touches
                if (changedTouches.length == this.touchesCount) {
                    t = changedTouches[0];
                }
            }
            else {
                t = ev;
            }
            
            return t ? this.formatTouch(t) : false;
        },

        formatTouch: function(ev) {
            var x = typeof ev.pageX == 'undefined' ? ev.x : ev.pageX;
            var y = typeof ev.pageY == 'undefined' ? ev.y : ev.pageY;

            return { 
                x: x,
                y: y,
                t: new Date().getTime()
            }
        },

        /**
         * Fire events attached callbacks
         */
        fire: function(eventName, args) {
            for (var i in this.events[eventName]) {
                this.events[eventName][i].apply(this, args);
            }
        },

        /**
         * Always retranslate touch move event
         * Check if swipe width or height is greater then 0
         */
        fireTouchMove: function() {
            var t = this.formatSwipe();
            if (t.width > 0 || t.height > 0) {
                this.fire("touchmove", [t]);
            }
        },

        /**
         * Check if target is same as this.el or target is child of this.el
         */
        isTheElement: function(target) {
            return (target == this.el || this.isChild(target, this.el));
        },

        isChild: function(target, element) {
            var n = target.parentNode;
            while (n) {
                if (n == element) {
                    return true;
                }
                n = n.parentNode;
            }
            return false;
        },

        addEvent: function(obj, type, fn) {
            if ( obj.attachEvent ) {
                obj['e'+type+fn] = fn;
                obj[type+fn] = function(){obj['e'+type+fn](window.event)}
                obj.attachEvent('on'+type, obj[type+fn]);
            }
            else {
                obj.addEventListener(type, fn, false);
            }
        },

        removeEvent: function(obj, type, fn) {
            if ( obj.detachEvent ) {
                obj.detachEvent( 'on'+type, obj[type+fn] );
                obj[type+fn] = null;
            }
            else {
                obj.removeEventListener(type, fn, false);
            }
        },

        preventEvent: function(ev) {
            if (ev.preventDefault) {
                ev.preventDefault();
            }
            else {
                ev.returnValue = false;
            }
        },

        /**
         * Normalize event.target
         */
        eventTarget: function(ev) {
            var el;

            if (ev.target) {
                el = ev.target;
            }
            else if (ev.srcElement) {
                el = ev.srcElement
            }
            
            // Safari bug. Selected text returns text
            if (el.nodeType == 3) {
                el = el.parentNode
            }

            return el;
        },

        /**
         * Add event listener
         */
        on: function(eventName, cb) {
            if (typeof this.events[eventName] == "object") {
                this.events[eventName].push( cb );
            }

            return this;
        },

        /**
         * Set configuration parameters
         */
        config: function(config) {
            function formatValue(value, type) {
                switch (type) {
                    case 'int': return parseInt(value, 10);
                    default: return value
                }
            }

            var defConfig = {
                direction:  {value: false, type: 'string'},

                minWidth: {value: false, type: 'int'},
                minHeight: {value: false, type: 'int'},
                minDuration: {value: false, type: 'int'},

                maxWidth: {value: false, type: 'int'},
                maxHeight: {value: false, type: 'int'},
                maxDuration: {value: false, type: 'int'}
            }

            // Init empty config
            this._config = {};

            // Append defaults
            for (var p in defConfig) {
                this._config[p] = typeof config[p] == 'undefined' ? defConfig[p].value : formatValue(config[p], defConfig[p].type);
            }
        },

        /**
         * Destroy swipe monitoring
         */
        destroy: function() {
            // Remove all event listeners
            this.handleEvents('remove');
            this.events = [];
        }
    }

    return Swipe;
});
},{}],15:[function(require,module,exports){
/**
 * Utility functions. Lean underscore/lodash/jquery version
 */

;(function(factory) {
    if (typeof module === 'object' && module.exports) {
        // CommonJS module   
        module.exports = factory();
    }
    else {
        // Global
        if (typeof window.webit == 'undefined') {
            window.webit = {}
        }
        window.webit._ = factory();
    }
})(function(){

    /**
     * jQuery object
     */
    var $;

    return {

        /**
         * Set jQuery object.
         * Even in CommonJs modules there can be case when jQuery cant be loaded
         * as module
         * In case of Wordpress it should be as extrernal dependency
         */
        jQuery: function(jQuery) {
            $ = jQuery;
        },

        /**
         * Bind function execution to provided scope
         */
        bind: function(func, scope) {
            return function(){
                return func.apply(scope, arguments);
            }
        },

        clone: function(obj) {
            var n = {};
            for (var i in obj) {
                if (obj.hasOwnProperty(i)) {
                    n[i] = obj[i];
                }
            }
            return n;
        },

        /**
         * Delay function execution by delay milisecond
         * @param function Function
         * @param number Delay
         * @param object Function scope
         */
        delay: function(cb, delay, scope) {
            delay = delay || 0;

            if (scope) {
                cb = this.bind(cb, scope);
            }
            window.setTimeout(cb, delay);
        },

        /**
         * Debounce function execution
         */
        debounce: function(cb, delay, scope) {
            var t = 0;
            return function() {
                window.clearTimeout(t);
                t = window.setTimeout(function(){
                    cb.apply(scope)
                }, delay)
            }
        },

        /**
         * Izpildām funkciju noteiktu skaitu reižu
         */
        times: function(cb, times, scope) {
            for (var i = 0; i < times; i++) {
                cb.apply(scope, [i]);
            }
        },

        /**
         * Palaižam doneCallback, pēc tam, kad atgrieztā 
         * funkcija palaista count reizes
         */
        after: function(count, doneCallback) {
            var counter = 0;
            return function() {
                counter++;
                if (counter == count) {
                    doneCallback();
                }
            }
        },

        each: function(items, cb, scope) {
            scope = scope || this;
            for (var i in items) {
                if (cb.apply(scope, [items[i]]) === false) {
                    break;
                }
            }
        },

        /**
         * Ģenerējam range masīvu, kura vērtības ir padotā 
         * callback atgrieztā vērtība.
         * Padotajam callback tiek padots items no range masīva
         * Ja ir padots callback, tad izsaucam to uz katru item range masīvā
         * @param number Range start
         * @param number Range stop
         * @param function Callback, ko izsauks uz katru item range masīvā
         * @param object Scope, uz kuru izpildīt callback
         */
        ranger: function(start, stop, cb, scope) {
            if (stop == null) {
                stop = start || 0;
                start = 0;
            }
            // Ja stop ir mazāks par start, tad step ir -1
            step = (stop < start ? -1 : 1);
            scope = scope || this;

            var length = Math.max(Math.ceil((stop - start) / step), 0);
            var range = Array(length);

            for (var i = 0; i < length; i++, start += step) {
                if (typeof cb == 'function') {
                    range.push(cb.call(scope, start));
                }
            }

            return range;
        },

        /**
         * Normalizējam masīva indeksu
         * Ja indekss ir lielāks vai mazāks par masīva length, tad uzskatām, ka
         * tas loopojas pa masīvu, kamēr atrod savu vietu
         */
        normalizeIndex: function(index, length) {
            index = index % length;
            return index < 0 ? length + index : index;
        },

        /**
         * You should not slice on arguments because it prevents optimizations in JavaScript 
         * engines (V8 for example). Instead, try constructing a new array by iterating 
         * through the arguments object.
         * @url https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments
         */
        getArguments: function(offset, argumentObj) {
            var a = [];
            for (var i = offset; i < argumentObj.length; i++) {
                a.push(argumentObj[i]);
            }
            return a;
        },

        /**
         * Check if provided number is not less than 0 and not bigger then max
         * If less then 0, then 0
         * If bigger then max, then max
         * When reStart is true, then when reached max turn varianle into 0
         * and if less then 0, then turn into max
         */
        checkBoundry: function(i, max, reStart) {
            if (i < 0) {
                i = reStart ? max-1 : 0;
            }
            else if (i >= max) {
                i = reStart ? 0 : max-1;
            }

            return i;
        },

        
        /**
         * Visas šīs metode pārtaisīt bez jQuery
         */
        addClass: function(el, className) {
            $(el).addClass(className);
        },

        removeClass: function(el, className) {
            $(el).removeClass(className);
        },

        append: function(target, el) {
            $(el).appendTo(target);
        },

        remove: function(el) {
            $(el).remove();
        },

        createEl: function(tagName) {
            return $('<'+tagName+'/>').get(0);
        },

        css: function(el, css) {
            $(el).css(css);
        },

        attr: function(el, name, value) {
            $(el).attr(name, value);
        },

        width: function(el) {
            return $(el).width();
        },

        height: function(el) {
            return $(el).height();
        },

        on: function(el, eventName, callback) {
            $(el).on(eventName, callback);
        },

        extend: function(a, b) {
            return $.extend(a, b);
        }
    }
});
},{}]},{},[3])(3)
});